package com.passwordmanager.utils;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.util.Arrays;
import java.util.Optional;
import java.util.Base64;

/**
 * @author Patrick Kelly
 * Class which is used to hash user login passwords for security purposes.
 * Uses Optional container object to facilitate non-null object checking
 * instead of regular Strings.
 */
public class HashPassword
{
    private static final SecureRandom RANDOM = new SecureRandom();
    private static final int HASH_ITERATIONS = 65536; //pad the hash with multiple iterations
    private static final int BIT_LENGTH = 128;  //we are using 128 bits for our passwords
    private static final String HASH_ALGORITHM = "PBKDF2WithHmacSHA512"; //SHA512 hashing algorithm

    /**
     *
     * @param length pass in the bit length of the salt
     * @return salt value generated by this method
     */
    public static Optional<String> createSalt(final int length)
    {
        if (length < 1)
        {
            System.err.println("Error: Size of salt must be greater than 0");
            return Optional.empty();
        }
        //byte array to hold the salt
        byte[] salt = new byte[length];
        RANDOM.nextBytes(salt);

        return Optional.of(Base64.getEncoder().encodeToString(salt));
    }

    /**
     *
     * @param password plaintext password to be hashed
     * @param salt salt generated by the createSalt() method
     * @return Optional container of type String. Empty returned if Exception is generated
     */
    public static Optional<String> createHash(String password, String salt)
    {
        //convert the password and salt to arrays
        char[] pwChars = password.toCharArray();
        byte[] bytes = salt.getBytes();
        //generate the hashed password using SHA512 algorithm with 65536 iterations
        PBEKeySpec spec = new PBEKeySpec(pwChars, bytes, HASH_ITERATIONS, BIT_LENGTH);
        //fill the arrays with min value \000 null character after spec is used
        Arrays.fill(pwChars, Character.MIN_VALUE);

        try
        {
            SecretKeyFactory factory = SecretKeyFactory.getInstance(HASH_ALGORITHM);
            byte[] safePassword = factory.generateSecret(spec).getEncoded();
            return Optional.of(Base64.getEncoder().encodeToString(safePassword));
        }
        catch (NoSuchAlgorithmException | InvalidKeySpecException e)
        {
            System.err.println("Exception occurred in createHash: " + e);
            e.printStackTrace();
            return Optional.empty();
        }
        finally
        {
            //clear the password info when finished
            spec.clearPassword();
        }
    }

    /**
     *
     * @param password pass in the plaintext password to be checked
     * @param salt salt generated by the createSalt() method.
     * @param key generated from the createHash() method
     * @return boolean value true if hashes match, else false
     */
    public static boolean checkPasswordMatch(String password, String salt, String key)
    {
        Optional<String> hashed = createHash(password, salt);
        return hashed.map(s -> s.equals(key)).orElse(false);
    }

}
